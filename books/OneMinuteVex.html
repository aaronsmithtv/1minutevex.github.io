<meta charset="utf-8">
<!-- Markdeep: https://casual-effects.com/markdeep/ -->



                                   		  **1 Minute VEX**
                                         [Aaron Smith][]
                                                <br>
                                     Version 1.0.0, 2022-04-19
                                                <br>
                      	Copyright 2020-2022 Aaron Smith. All rights reserved.



Overview
====================================================================================================

No matter what kind of Houdini tutorials you’ve searched or SideFX demonstrations you’ve seen, you’re likely to have come across the vast, incredibly powerful expression language that is VEX. It has quite the learning curve, as most languages do, but knowing how and when to use it efficiently can be amongst the most rewarding challenges in working with Houdini.

These tips are not intended for the Houdini or VEX beginner - they are an accumulation of the most useful snippets I have come across and written during the last few years. Having to trawl the internet for obscure code while under pressure to deliver can be very daunting; So I hope the following can be as convenient for you as they have been for myself.



U Attribute On Complex Curves
====================================================================================================

The surfacedist() function
---------------------
In this example, we use the 'surfacedist' function to find a point's distance from a target group. For our purposes, <kbd>"end_pts"</kbd> represents the group of points at the tip of our tree's branches.

By iterating surfacedist() over each point, we can build a range of distances to this target group, beginning at the furthest edge, and always ending at 0. We can then use a handy trick promoting these values as min/max to detail.

Finally, we use a second wrangle to fit the min/max distances to a 0-1 range; As the u attribute on a series of complex interconnected curves.


Houdini Implementation
---------------------
<div class='together'>
Let’s initialize our surfdist min & max attributes:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C
    // VEX surfacedist - Point Wrangle example

    int closest_pt;

    // Find the distance from point along edges to the target point group.
    f@surfdist = surfacedist(0, "end_pts", "P", @ptnum, closest_pt, "edge");

    // Store the min and max point edge distances as detail attributes.
    setdetailattrib(0, "surfdist_min", f@surfdist, "min");
    setdetailattrib(0, "surfdist_max", f@surfdist, "max");


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [Listing [imvt1-ptwA]: <kbd>[VEXpression - Point Wrangle 1]</kbd> The surfacedist() function]
</div>

<div class='together'>
Now we have surface distance and its' min and max values, we can constrain it to a 0-1 range.

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C
    // Read the min & max attributes from detail.

    float sd_min = detail(0, "surfdist_min");
    float sd_max = detail(0, "surfdist_max");

    // Fit the edge distance into a 0-1 range.
    @u = fit(f@surfdist, sd_min, sd_max, 0, 1);


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [Listing [imvt1-ptwB]: <kbd>[VEXpression - Point Wrangle 2]</kbd> Fitting the surfdist attribute]
</div>



Sampling Attributes with uvdist() and primuv()
====================================================================================================

The uvdist() function
---------------------
In this example, we continue with our tree - assigning ‘u’ to the 1st vector component of ‘uv’.

By isolating our primitive number (converting it to a string ‘group name’), we can use the ‘uvdist’ function to detect how far our sample position ‘spos’ is from the current prim.

We then compare our distance to a minimum tolerance; If the sampled distance to the prim is less, ‘primuv’ (in conjunction with our exported ‘dprim’ and ‘duv’ variables) is used to extract our desired attribute across all possible instances.


Houdini Implementation
---------------------
<div class='together'>
Using a primitive wrangle to iterate over all of our object's curves, let's evaluate our desired sample position.

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C
	// VEX uvdist & primuv - Primitive Wrangle example

	// Assign u sample variable from spare parameter.
	vector spos = set(chf("sample_u"), 0, 0);

	// Assign current primitive as variable group name.
	string prnum = itoa(@primnum);

	// Export UV distance, parametric coordinates at UV position.
	int dprim; vector duv;
	float dist = uvdist(0, prnum, "uv", spos, dprim, duv);

	// Assign variable minimum tolerance for uv distance sampling.
	float tol = pow(10, -8)

	if(dist < tol)
	{
		// Sample world position using parametric coordinates.
		vector pos = primuv(0, "P", dprim, duv);

		// Add a new point, with point group at sampled world position
		int newpt = addpoint(geoself(), pos);
		setpointgroup(geoself(), "uv_sampled_pts", newpt, 1, "set");

	}
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [Listing [imvt2-prwA]: <kbd>[VEXpression - Primitive Wrangle 1]</kbd> The surfacedist() function]
</div>



[Aaron Smith]:      https://github.com/aaronsmithtv



<!-- Markdeep: https://casual-effects.com/markdeep/ -->
<link rel='stylesheet' href='../style/book.css'>
<style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style>
<script src="markdeep.min.js"></script>
<script src="https://morgan3d.github.io/markdeep/latest/markdeep.min.js"></script>
<script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>