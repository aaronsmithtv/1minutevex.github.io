<meta charset="utf-8">
<!-- Markdeep: https://casual-effects.com/markdeep/ -->



                                   		  **1 Minute VEX**
                                         [Aaron Smith][]
                                                <br>
                                     Version 1.0.0, 2022-04-19
                                                <br>
                      	Copyright 2020-2022 Aaron Smith. All rights reserved.



Overview
====================================================================================================

No matter what kind of Houdini tutorials you’ve searched or SideFX demonstrations you’ve seen, you’re likely to have come across the vast, incredibly powerful expression language that is VEX. It has quite the learning curve, as most languages do, but knowing how and when to use it efficiently can be amongst the most rewarding challenges in working with Houdini.

These tips are not intended for the Houdini or VEX beginner - they are an accumulation of the most useful snippets I have come across and written during the last few years. Having to trawl the internet for obscure code while under pressure to deliver can be very daunting; So I hope the following can be as convenient for you as they have been for myself.



U Attribute On Complex Curves using surfacedist()
====================================================================================================

The surfacedist() function
---------------------
In this example, we use the 'surfacedist' function to find a point's distance from a target group. For our purposes, <kbd>"end_pts"</kbd> represents the group of points at the tip of our tree's branches.

By iterating surfacedist() over each point, we can build a range of distances to this target group, beginning at the furthest edge, and always ending at 0. We can then use a handy trick promoting these values as min/max to detail.

Finally, we use a second wrangle to fit the min/max distances to a 0-1 range; As the u attribute on a series of complex interconnected curves.


Houdini Implementation
---------------------
<div class='together'>
Let’s initialize our surfdist min & max attributes:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C
    // VEX surfacedist - Point Wrangle example

    int closest_pt;

    // Find the distance from point along edges to the target point group.
    f@surfdist = surfacedist(0, "end_pts", "P", @ptnum, closest_pt, "edge");

    // Store the min and max point edge distances as detail attributes.
    setdetailattrib(0, "surfdist_min", f@surfdist, "min");
    setdetailattrib(0, "surfdist_max", f@surfdist, "max");


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [Listing [imvt1-ptwA]: <kbd>[VEXpression - Point Wrangle 1]</kbd> The surfacedist() function]
</div>

<div class='together'>
Now we have surface distance and its' min and max values, we can constrain it to a 0-1 range.

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C
    // Read the min & max attributes from detail.

    float sd_min = detail(0, "surfdist_min");
    float sd_max = detail(0, "surfdist_max");

    // Fit the edge distance into a 0-1 range.
    @u = fit(f@surfdist, sd_min, sd_max, 0, 1);


    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [Listing [imvt1-ptwB]: <kbd>[VEXpression - Point Wrangle 2]</kbd> Fitting the surfdist attribute]
</div>



Sampling Attributes with uvdist() and primuv()
====================================================================================================

The uvdist() function
---------------------
In this example, we continue with our tree - assigning ‘u’ to the 1st vector component of ‘uv’.

By isolating our primitive number (converting it to a string ‘group name’), we can use the ‘uvdist’ function to detect how far our sample position ‘spos’ is from the current prim.

We then compare our distance to a minimum tolerance; If the sampled distance to the prim is less, ‘primuv’ (in conjunction with our exported ‘dprim’ and ‘duv’ variables) is used to extract our desired attribute across all possible instances.


Houdini Implementation
---------------------
<div class='together'>
Using a primitive wrangle to iterate over all of our object's curves, let's evaluate our desired sample position.

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C
	// VEX uvdist & primuv - Primitive Wrangle example

	// Assign u sample variable from spare parameter.
	vector spos = set(chf("sample_u"), 0, 0);

	// Assign current primitive as variable group name.
	string prnum = itoa(@primnum);

	// Export UV distance, parametric coordinates at UV position.
	int dprim; vector duv;
	float dist = uvdist(0, prnum, "uv", spos, dprim, duv);

	// Assign variable minimum tolerance for uv distance sampling.
	float tol = pow(10, -8)

	if(dist < tol)
	{
		// Sample world position using parametric coordinates.
		vector pos = primuv(0, "P", dprim, duv);

		// Add a new point, with point group at sampled world position
		int newpt = addpoint(geoself(), pos);
		setpointgroup(geoself(), "uv_sampled_pts", newpt, 1, "set");

	}

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [Listing [imvt2-prwA]: <kbd>[VEXpression - Primitive Wrangle 1]</kbd> The surfacedist() function]
</div>



Ray-Cast Ambient Occlusion using intersect()
====================================================================================================

The intersect() & sample_hemisphere() functions
---------------------
In this example, we begin by creating a variable for position - offsetting it from the surface very slightly to avoid unintended ray intersections.

Once we have assigned how many samples we want, and the hemispherical radius of our ambient occlusion (which determines how close geometry has to be to occlude), we use a for loop to iterate over each sample.

We then generate a random hemispherical direction using our point normal, and use that directional vector as the ray. If our ray hits geometry, its distance from initial position is fit within a 1-0 range - 1 being the closest a ray could possibly be, and 0 being the furthest.

This value is added and accumulated through the ‘ao’ variable, and then divided by the total number of samples added to the variable. We finally return the complement, in order to make close intersections dark, and distant rays / non intersections bright.


Houdini Implementation
---------------------
<div class='together'>
Using a point wrangle, we create a loop that will sample and average occluding ray intersections.

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C
	// VEX sample_hemisphere & intersect - Point Wrangle example

	// Assign initial variables, including P with small surface offset.
	vector pos = @P + (@N * pow(10, -6));
	int samples = 256; float radius = 0.1; float ao;

	for(int i = 0; i < samples; i++)
	{
		// For each sample, create a random hemispherical direction using N.
		vector2 seed = rand(@ptnum + i);
		vector dir = sample_hemisphere(@N, seed);

		// Export position of directional intersection, limited to radius.
		vector ipos; vector iuvw;
		float isect = intersect(0, pos, dir * radius, ipos, iuvw);

		// If intersection is found, fit ray length into a 1-0 range and
		// add the result to the accumulating variable 'ao'.
		if(isect != -1)
		{
			ao += fit(distance(ipos, pos), 0, radius, 1, 0);
		}
	}
	// When all samples are iterated over, divide the total ao sum by
	// total number of samples, then returning its complement.

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [Listing [imvt3-ptwA]: <kbd>[VEXpression - Point Wrangle 1]</kbd> The intersect() function]
</div>



NDC Space (Normalized Device Coordinates) & VEX
====================================================================================================

An Introduction to Normalized Device Coordinates
---------------------
Normalized Device Coordinate or NDC space is a coordinate system used in rendering, mapping our display to a cube (known as the ‘view volume’) wherein x, y and z are within the range -1 to 1.

Transforming vertices to NDC space is the essential intermediary between world space and screen space (our 3D mapped to 2D pixels) - and can be a tricky subject to understand without any pre-existing knowledge on linear mapping.

Luckily, SideFX has done the heavy lifting for us! Using toNDC() we can provide a camera and point position in order to translate P into its respective NDC.


Part 1: Scaling Objects by Camera NDC
---------------------
In this example, we begin by providing a camera path as string. We use the chs() function, as this spare parameter has a great deal of node finding utility.

Once we have converted P to NDC, we can multiply the z component of our new coordinates. This will keep our points within the exact same display position, but drawing that relative position closer/further to our camera.

Now that we have our adjusted position, we convert our NDC back to world position and assign to P.


### Houdini Implementation
	<div class='together'>
	Using a point wrangle, find our point's position in a camera's relative space and modify the resulting position.

	    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C
		// VEX toNDC & fromNDC - Point Wrangle Example

	    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	    [Listing [imvt4-ptwA]: <kbd>[VEXpression - Point Wrangle 1]</kbd> Scaling with NDC Space]
	</div>


Part 2: Culling Points by Camera NDC
---------------------
For this example, we begin once again by creating a variable camera path as a string parameter. 

We then set up our ‘cull_scale’ which is the proportion of the display that will be culled. In order to have our parameter retain 0% of the display at 0, and 100% at 1, we multiply the scale by 0.5 (1 / number of axes) and initialize our min and max at the same - with min being subtracted from, and max being added to.

Once we have converted P to NDC, we can compare each float component of our vector to its relevant min/max positions. If it is outside the min/max, an array value will be 1 (true). Z values above 0 are culled because NDC space is a right hand coordinate system.

Finally, using foreach, we loop over each comparison. If the axis has returned true for sitting outside of our bounds, we remove the point and exit the looping process.


### Houdini Implementation
	<div class='together'>
	Using a point wrangle, find our point's position in a camera's relative space and cull it if it lies outside of the camera frustum.

	    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C
		// VEX toNDC & removepoint - Point Wrangle Example

	    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	    [Listing [imvt5-ptwA]: <kbd>[VEXpression - Point Wrangle 1]</kbd> Culling with NDC Space]
	</div>



Camera Occlusion Culling using intersect()
====================================================================================================

An Introduction to Occlusion Culling in Houdini
---------------------
Occlusion culling is the process of removing geometry unseen by the camera. It is a technique often used in video game rendering, with the purpose of optimising performance and keeping the time to generate a single frame low. 

In Houdini, occlusion culling can be a great way to keep particle sim file sizes low, and separate what is in view from what is not.

The intersect() & optransform() functions
---------------------
In this example, we begin by creating a string path variable for our occlusion object. While functions we have used so far take raw string paths as their input, to use intersect we must append our path to ‘op:’.

We then create a transformation matrix from camera path using optransform; This allows us to multiply said matrix with an initialised position and return our camera’s position.

Next, we need to find the direction and length of our point-to-camera ray. For direction, we subtract point position from camera position and normalize it. For length, we simply use the distance function.

Once we have all of our variables, we assign them to their respective positions with intersect. If the ray (direction multiplied by distance) does not hit our geometry, it will return -1. Therefore, we remove our point if it returns anything else.


Houdini Implementation
---------------------
<div class='together'>
Using a point wrangle, we must find the occluding OBJ operator, and find out if our points intersect the path between it and our camera source.

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C
	// VEX optransform & intersect - Point Wrangle Example
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [Listing [imvt6-ptwA]: <kbd>[VEXpression - Point Wrangle 1]</kbd> Camera to point occlusion]
</div>



[Aaron Smith]:      https://github.com/aaronsmithtv



<!-- Markdeep: https://casual-effects.com/markdeep/ -->
<link rel='stylesheet' href='../style/book.css'>
<style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style>
<script src="markdeep.min.js"></script>
<script src="https://morgan3d.github.io/markdeep/latest/markdeep.min.js"></script>
<script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>